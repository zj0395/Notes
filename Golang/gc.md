# GoLang gc
非分代，非紧缩，写屏障，并发标记清理

## 常用gc算法
### 引用计数
- c++ `shared_ptr`
- 无法解决循环引用的问题

### Mark-Sweep
- 先标记出使用中的
- 再回收未使用的

### Mark-Compact
- 相比`Mark-Sweep`减少了内存碎片

### 复制算法
- 内存利用率太低

### 分代收集
- 按生命周期将对象分为两代或多代
- 较新的代内gc会更频繁
- 生命周期长的对象会被转移到较老代中

### 三色标记
#### 步骤：
1. 起始所有对象都是白色
2. 从根出发扫描到的所有可达对象，变为灰色
3. 扫描每个灰色对象，将灰色置为黑色，并将其可达的白色对象置为灰色
4. 重复3，直到没有灰色对象

#### 会产生的问题和解决方法
浮动垃圾：扫描A时将B标记为灰色，随后A取消了对B的引用，B成为浮动垃圾，本次gc不会回收B。但下次gc会回收，影响不大
漏标：扫描A时A无引用，扫描A以后用户程序将A对象引用了B对象，此时B对象未被标记
#### 写屏障
解决漏标的问题
A对象被标黑以后，如果A引用了B对象，则将B对象也标灰
插入写屏障：执行指针赋值时，如果指向的内存区域为白色，则将其标记为灰色，在运行三色标记
删除写屏障：如果A被标记为灰色后被释放了，则会将其指向的白色内存标记为灰色

#### 优点：
1. 标记时不用stop the world
